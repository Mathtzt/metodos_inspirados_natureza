import pygad as pga

class AlgoritmoGenetico(pga.GA):
    def __init__(self,
                 problema,
                 total_geracoes=100,
                 tamanho_populacao=50,
                 total_pais_cruzamento=2,
                 tipo_selecao_pais="rws",
                 total_pais_manter_populacao=-1,
                 total_pais_torneio=3,
                 tipo_cruzamento="single_point",
                 taxa_cruzamento=0.9,
                 tipo_mutacao="random",
                 taxa_mutacao=0.05,
                 elitismo=1,
                 salvar_melhores_solucoes=True,
                 salvar_todas_solucoes=False,
                 semente_aleatoriedade=None):
        pga.GA.__init__(self=self,
                        num_generations=total_geracoes,
                        sol_per_pop=tamanho_populacao,
                        fitness_func=self.funcao_avaliacao_qualidade_solucao,
                        fitness_batch_size=None,
                        num_genes=problema.dimensao,
                        gene_type=[float]*problema.dimensao,
                        gene_space=None,
                        allow_duplicate_genes=True,
                        init_range_low=problema.limite_inferior,
                        init_range_high=problema.limite_superior,
                        initial_population=None,
                        num_parents_mating=total_pais_cruzamento,
                        parent_selection_type=tipo_selecao_pais,
                        K_tournament=total_pais_torneio,
                        keep_parents=total_pais_manter_populacao,
                        crossover_type=tipo_cruzamento,
                        crossover_probability=taxa_cruzamento,
                        mutation_type=tipo_mutacao,
                        mutation_probability=taxa_mutacao,
                        mutation_by_replacement=True,
                        mutation_percent_genes=5,
                        mutation_num_genes=None,
                        random_mutation_min_val=problema.limite_inferior,
                        random_mutation_max_val=problema.limite_superior,
                        keep_elitism=elitismo,
                        stop_criteria="saturate_" + str(total_geracoes),
                        random_seed=semente_aleatoriedade,
                        parallel_processing=None,
                        on_start=None,
                        on_fitness=None,
                        on_parents=None,
                        on_crossover=None,
                        on_mutation=None,
                        on_generation=None,
                        on_stop=None,
                        delay_after_gen=0.0,
                        save_best_solutions=salvar_melhores_solucoes,
                        save_solutions=salvar_todas_solucoes,
                        suppress_warnings=False,
                        logger=None)

        self.problema = problema

    def funcao_avaliacao_qualidade_solucao(self,
                                           algoritmo_ag,
                                           x,
                                           indice_solucao):
        return 1.0 / self.problema.funcao_objetivo(x=x)